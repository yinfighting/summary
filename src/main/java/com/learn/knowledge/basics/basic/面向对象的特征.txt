解读：

      1.抽象：

      通俗解析：抽象就是把一个对象分析出各个属性， 来替代表达的手法 。

抽就是抽离；象 ，表象。

对于一类事物，它的个体有共同的地方，也有不同的地方。我们把它们共同的一部分可以详细描述，但是特别的地方就不能一 一描述了，此时，可以把这部分特别的地方抽象为一个方法。此时，就形成了抽象方法，由于一个类中如果具有抽象方法，这个类也要描述为抽象类，即抽象类。

     Java解析：如果一个类没有足够的信息来描述一个具体的对象，而需要其他具体的类来支撑它，那么这样的类我们称它为抽象类。抽象包括两个方面，一是过程抽象,二是数据抽象。

    抽象中相关知识：

1.     从以上解读可以获取到的抽象有如下概念：

抽象类中，可以存在抽象方法，普通方法，也可以存在普通变量，抽象变量。

2.     由于它是对一类事物的总描述，所以，抽象类比较与普通类，具有如下特点：

1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。

2、抽象方法必须由子类来进行重写。

3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。

4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。

5、子类中的抽象方法不能与父类的抽象方法同名。

6、abstract不能与final并列修饰同一个类。

7、abstract 不能与private、static、final或native并列修饰同一个方法。

    3. 提到抽象，就不得提一提“接口”，他们就像孪生兄弟，有着相同的地方，又有着截然不同的区别之处。

       以下是接口与抽象的区别：

       

参数                                          抽象类                                                  接口

默认的方法实现            它可以有默认的方法实现                                              接口完全是抽象的。它根本不存在方法的实现

实现                    子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，            子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现
                        它需要提供抽象类中所有声明的方法的实现。

构造器                  抽象类可以有构造器                                                    接口不能有构造器

与正常Java类的区别       除了不能实例化抽象类之外，它和普通Java类没有任何区别                   接口是完全不同的类型

访问修饰符               抽象方法可以有public、protected和default这些修饰符                    接口方法默认修饰符是public。你不可以使用其它修饰符。

main方法                 抽象方法可以有main方法并且我们可以运行它                              接口没有main方法，因此我们不能运行它。

多继承                   抽象方法可以继承一个类和实现多个接口                                  接口只可以继承一个或多个其它接口

速度                     它比接口速度要快                                                     接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。




接口和抽象使用时机：

1.如果拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类。

2.如果实现多重继承，那么必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此就可以使用接口来解决它。

3.如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。

2.继承：

  通俗解析：相当于儿子继承父亲的遗产，而其中，父亲私有的东西是不允许继承的，其他的，比如钱，物件，都可以由儿子去消费，使用。儿子在此基础上可以对父亲的物品就行更新，也可以自己去扩展。

  Java解析： 继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。 子类又被称为派生类； 父类又被称为超类（Super Class）。

继承的特点：

1.     子类即使不扩充父类，也能维持父类的操作。

2.     子类实际上是将父类定义的更加的具体化的一种手段。

3.     父类表示的范围大，而子类表示的范围小。

继承的限制：

  本段参考网址：详细资料详见：http://blog.csdn.net/wei_zhi/article/details/52780026

1.     一个子类只能够继承一个父类，存在单继承局限。

结论：Java之中只允许多层继承，不允许多重继承，Java存在单继承局限。

2.     在一个子类继承的时候，实际上会继承父类之中的所有操作（属性、方法），但是需要注意的是，对于所有的非私有（no private）操作属于显式继承（可以直接利用对象操作），而所有的私有操作属于隐式继承（间接完成）。

3. 在继承关系之中，如果要实例化子类对象，会默认先调用父类构造，为父类之中的属性初始化，之后再调用子类构造，为子类之中的属性初始化，即：默认情况下，子类会找到父类之中的无参构造方法。

  super和this的问题

  本段参考网址：详细资料详见：http://www.cnblogs.com/hasse/p/5023392.html

this：

   通俗解释：this是自己指向自己，目的是确定这个确实是自己。

  

Java解释：this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。

   super:

   通俗解释：自己指向父亲，将父亲的东西拿来自己用，这个东西可能自己没有，或者自己也有，并且和父亲的相同。自己没有的时候，可以省略这个标记。这个标记是不能指向自己的爷爷的。

   Java解释：指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。

   this使用场景：

1.     面向自身类,普通的直接引用

2.     在形参和成员变量相同的情况下用来区分。

3.     this可以用于一个构造方法对另一构造方法的引用（应该为构造函数中的第一条语句）。

   super使用场景：

1.     面向父类取变量或者方法等

2.     调用父类中的某一个构造函数（应该为构造函数中的第一条语句）

   this和super注意事项：

·        super（参数）：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） 

·        this（参数）：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）

·        super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名    super.成员函数据名（实参）

·        this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）

·        调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。

·        super()和this()类似,区别是，super()从子类中调用父类的构造方法，this()在同一类内调用其它方法。

·        super()和this()均需放在构造方法内第一行。

·        尽管可以用this调用一个构造器，但却不能调用两个。

·        this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。

·        this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。

·        从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。

 3.封装(略)

3.     多态：详细参考网址：http://www.cnblogs.com/chenssy/p/3372798.html

通俗解释：一对多关系

Java解释：父类引用子类对象

  多态中应该注意的事项：

    指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）

    如果一定要使用子类自身的方法，这时候就要将多态性向下转型，即强制转换类型，此时多态性转化为自身类型。

 
重写 总结：
1.发生在父类与子类之间
2.方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同
3.访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private)
4.重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常
重载 总结：
1.重载Overload是一个类中多态性的一种表现
2.重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)
3.重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准

面试时，问：重载（Overload）和重写（Override）的区别？
    答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。
重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；
重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，
不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。


